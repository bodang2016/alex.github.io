{"meta":{"title":"Hotel Yamato","subtitle":null,"description":null,"author":"Alex Wang","url":"http://bodang2016.github.io"},"pages":[{"title":"About","date":"2017-08-15T21:45:36.994Z","updated":"2017-08-15T21:45:36.994Z","comments":true,"path":"about/index.html","permalink":"http://bodang2016.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-08-15T21:45:37.046Z","updated":"2017-08-15T21:45:37.046Z","comments":true,"path":"categories/index.html","permalink":"http://bodang2016.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-15T21:45:37.020Z","updated":"2017-08-15T21:45:37.020Z","comments":true,"path":"tags/index.html","permalink":"http://bodang2016.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"图的遍历方法学习笔记","slug":"GraphSearchLJ","date":"2017-08-16T14:58:49.000Z","updated":"2017-08-16T17:50:12.765Z","comments":true,"path":"2017/08/16/GraphSearchLJ/","link":"","permalink":"http://bodang2016.github.io/2017/08/16/GraphSearchLJ/","excerpt":"图的存储方式首先来看一个例子： 要实现图的遍历，需要先将图存储到一个数据结构中，最常用的存储方法是使用一个二维数组e来存储（邻接矩阵存储法），如下： 二维数组中第i行第j列表示的就是顶点i到顶点j是否有边， ∞表示没有边 1表示有边 0表示自己到自己 无向图的邻接矩阵是对称的，实现的时候可以考虑压缩","text":"图的存储方式首先来看一个例子： 要实现图的遍历，需要先将图存储到一个数据结构中，最常用的存储方法是使用一个二维数组e来存储（邻接矩阵存储法），如下： 二维数组中第i行第j列表示的就是顶点i到顶点j是否有边， ∞表示没有边 1表示有边 0表示自己到自己 无向图的邻接矩阵是对称的，实现的时候可以考虑压缩 遍历基本算法深度优先（DFS）从1号顶点出发开始遍历这个图，采用深度优先可以得到下图的遍历结果 每个顶点上方的数字代表这个顶点在第几步被访问，由于我不喜欢书上那种概念的描述方法，这里放一个我在别处看到的思想概括： 深度优先遍历的主要思想： 首先以一个未被访问的顶点作为起点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，回到上一个顶点，继续试探访问别的顶点，直到所有顶点都被访问过。简而言之，就是沿着一条分支遍历直到末端，然后回溯，再沿着另一条进行同样的遍历，知道所有顶点都被访问过。 下面上代码： 12345678910111213141516171819202122232425262728293031323334public class depthFirst &#123; List&lt;Integer&gt; book; //记录顶点是否被访问过 final int[][] edges = &#123; &#123; 0, 1, 1, 9, 1 &#125;, &#123; 1, 0, 9, 1, 9 &#125;, &#123; 1, 9, 0, 9, 1 &#125;, &#123; 9, 1, 9, 0, 9 &#125;, &#123; 1, 9, 1, 9, 0 &#125; &#125;; //邻接矩阵 int scanned = 0; //已遍历的顶点 int verticeNum = 5; //顶点总数 private void dfs(int vertex) &#123; if (book.contains(vertex)) //如果顶点已被遍历过，返回上一级递归 return; //将顶点标为已遍历，输出顶点编号 scanned++; book.add(vertex); System.out.println(vertex); if (scanned == verticeNum) //如果已遍历全部顶点，返回上一级递归 return; for (int i = 0; i &lt; verticeNum; i++) &#123; //继续向下递归 if (edges[vertex][i] == 1) &#123; dfs(i); &#125; &#125; return; &#125; public static void main(String[] args) &#123; depthFirst test = new depthFirst(); test.book = new ArrayList&lt;Integer&gt;(); test.dfs(0); &#125;&#125; 代码的具体逻辑已经注释的很清晰这里不再解释，值得归纳的是深度优先算法使用的递归思想；为了加深对思想的理解我总结了DFS算法的三个递归条件： 边界条件：已遍历顶点等于总顶点（同一连通图） 递归前进段：当前顶点有未遍历过的相邻顶点 递归返回段：返回上一级顶点 广度优先（BFS）同样的我们还看刚才的例子，从1号顶点出发，采用广优先可以得到下图的遍历结果 广度优先的主要思想： 首先以一个未被访问过的顶点作为起始顶点，访问所有与其相邻的顶点，然后对每一个相邻的顶点，再访问它们相邻的并且未被访问过的顶点，直到所有顶点都被访问过，遍历结束。 下面上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class breadthFirst &#123; List&lt;Integer&gt; book; // 记录顶点是否被访问过 final int[][] edges = &#123; &#123; 0, 1, 1, 9, 1 &#125;, &#123; 1, 0, 9, 1, 9 &#125;, &#123; 1, 9, 0, 9, 1 &#125;, &#123; 9, 1, 9, 0, 9 &#125;, &#123; 1, 9, 1, 9, 0 &#125; &#125;; // 邻接矩阵 int scanned = 0; // 已遍历的顶点 int verticeNum = 5; // 顶点总数 Queue&lt;Integer&gt; waitList; //遍历结果队列 public void bfs(int vertex) &#123; waitList.add(vertex); //向队列中加入首个顶点，并将该点标记为已访问 book.add(vertex); scanned++; while (waitList.size() &gt; 0) &#123; //在队列中还有顶点时持续遍历 int curVertex = waitList.poll(); //一次取出一个顶点，输出其数值并遍历其所有未访问的邻居 System.out.println(curVertex); for (int i = 0; i &lt; verticeNum; i++) &#123; if (edges[curVertex][i] == 1 &amp;&amp; !book.contains(i)) &#123; scanned++; book.add(i); waitList.add(i); &#125; &#125; if (scanned == verticeNum) //如果所有顶点都已访问，直接跳出循环 break; &#125; while(waitList.size() &gt; 0) &#123; //顺序输出队列中剩余的顶点 System.out.println(waitList.poll()); &#125; &#125; public static void main(String[] args) &#123; breadthFirst test = new breadthFirst(); test.book = new ArrayList&lt;Integer&gt;(); test.waitList = new LinkedList&lt;Integer&gt;(); test.bfs(0); &#125;&#125; 代码中使用了Queue来对遍历的结果进行保存，这是因为队列先进先出的特性与广度优先的逻辑相同，我们可以将广度优先的关键逻辑总结成两句话 先访问当前顶点的所有邻接点 先访问先被访问的顶点的邻接点（好绕口= =） 上面写的两种算法均使用了ArrayList作为判断顶点是否被访问过的依据，但在遍历的图有两个以上的点入度为0时，或是在遍历森林时，这种方法会加大检索未与起始顶点连通的顶点的复杂度。这里可以考虑使用数组代替ArrayList，当时选择这种方法的原因是因为数组需要在建立时确定长度，但后来一想反正顶点也是二维数组用存的，再用一个数组应该也不会有越界的风险2333，后面具体遇到问题再分析就行。 算法比较 深度优先算法：不保留全部节点，占用内存小，有回溯操作（即入栈，出栈），运行速度慢 广度优先算法：保留全部节点，占用内存大，无回溯操作(即无入栈、出栈)，运行速度快 通常深度优先搜索法不全部保留结点，扩展完的结点从内存中弹出，这样，一般在内存中存储的结点数就是最长的一条路径的值，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。 广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作，所以运行速度比深度优先搜索要快些。 小结这篇笔记主要总结了图的邻接矩阵存储方式和两种遍历方法，邻接矩阵表示法通常适用于一般的图的存储，对于边较少，顶点较多的图会浪费许多空间（稀疏矩阵），这种情况可以采用邻接表进行存储，后续会对两种方法进行细致的比对学习；深度优先和广度优先不仅在图的遍历中适用，在遍历二叉树等数据结构时同样适用。 参考阅读： Java中的递归原理分析 Future belongs to the few of us still wiling to get our hands dirty.","categories":[{"name":"Learning Journal","slug":"Learning-Journal","permalink":"http://bodang2016.github.io/categories/Learning-Journal/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://bodang2016.github.io/tags/Algorithm/"},{"name":"Graph","slug":"Graph","permalink":"http://bodang2016.github.io/tags/Graph/"}]},{"title":"Markdown语法学习笔记","slug":"MarkdownLJ","date":"2017-08-16T08:19:49.000Z","updated":"2017-08-16T17:59:56.711Z","comments":true,"path":"2017/08/16/MarkdownLJ/","link":"","permalink":"http://bodang2016.github.io/2017/08/16/MarkdownLJ/","excerpt":"Markdown的简要规则标题标题作为每一篇文章必需的组成部分，这里首先拿出来说一下。在Markdown中，如果一段文字被定义为标题，只要在这段文字前加#号即可。例如： 123# 一级标题## 二级标题### 三级标题 效果 一级标题二级标题###三级标题","text":"Markdown的简要规则标题标题作为每一篇文章必需的组成部分，这里首先拿出来说一下。在Markdown中，如果一段文字被定义为标题，只要在这段文字前加#号即可。例如： 123# 一级标题## 二级标题### 三级标题 效果 一级标题二级标题###三级标题 列表Markdown中的列表和Word，Pages中的一样，分为有序和无序表两种。列表的显示只需在文字前加上*或-；有序表则直接在文字前加1. 2. 3. ，符号和文字之间需要加一个空格。 1234- 无序表 1* 无序表 21. 有序表 12. 有序表 2 示例 无序表 1 无序表 2 有序表 1 有序表 2 引用如果文章中有引自别处的句子或段落，就要使用引用的格式。引用是可以嵌套的，只需要在文本前加入&gt;这种尖括号（大于号）即可，文本前有几个&gt;表示当前段落的引用层级，这里也要注意符号和文本间的空格。 12&gt;我引&gt;&gt;&gt;我再引233 示例 我引 我再引233 图片与链接插入图片和插入链接的语法很相似，区别在于一个!号，直接上代码 1234插入图片：![]()&#123;images/markdown-170816/yamato.png&#125;插入链接：[我的GitHub](github.com/bodang2016) 示例 这里直接拿打伞大姐姐做展示图了，YAAAMAATOOOO！ 链接示例：My GitHub 粗体 斜体 下划线Markdown中的粗体斜体也非常简单，用一个*包含一段文本就是斜体语法；用两个*包含就是粗体语法；用&lt;u&gt;和&lt;/u&gt;包裹语句就是下划线语法，下面为代码： 123*斜体语法***粗体语法**&lt;u&gt;下划线语法&lt;/u&gt; 示例 斜体语法粗体语法下划线语法 表格在Markdown中使用表格相对来说就比较累了，实现方式有好几种，但不管哪种方式，以下规则都是通用的。 第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开，原生方式每一行的两边都要有管道符。 第二行可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就是右对齐。 下面上代码： 12345|学号|姓名|分数||-|-|-:||小明|男|750||小红|女|110||小陆|男|99| 示例 学号 姓名 分数 小明 男 750 小红 女 110 小陆 男 99 代码框代码框在负责在文章中优雅地呈现代码，在Markdown中实现也非常简单，我常用的方式有两种： 用` 包裹代码文字，这种方法常用于在一行文字的中间穿插代码 用三个` 包裹代码文字并指定代码类型，这种方法常用于大段的代码 下面上代码： 1234567`public static void testFunction()`​···javapublic static void main(String[] args)&#123; testFunction();&#125;​···(此处换成英文字符) 示例 public static void testFunction() 123public static void main(String[] args)&#123; testFunction(); &#125; 分割线分割线的语法只需要三个*号，例如 123A B C D E***F G H I J 示例 A B C D E F G H I J 小结到这里，Markdown的日常语法就基本总结完了，在日后的日志中多加练习，配合好写作工具，写起东西来肯定会行云流水。更多的语法可以参考Markdown的官方文档或者写作工具的帮助文档。 Future belongs to the few of us still wiling to get our hands dirty.","categories":[{"name":"Learning Journal","slug":"Learning-Journal","permalink":"http://bodang2016.github.io/categories/Learning-Journal/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://bodang2016.github.io/tags/Markdown/"},{"name":"Language","slug":"Language","permalink":"http://bodang2016.github.io/tags/Language/"}]}]}