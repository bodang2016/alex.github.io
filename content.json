{"meta":{"title":"Hotel Yamato","subtitle":null,"description":null,"author":"Alex Wang","url":"http://bodang2016.github.io"},"pages":[{"title":"About","date":"2017-08-15T21:45:36.994Z","updated":"2017-08-15T21:45:36.994Z","comments":true,"path":"about/index.html","permalink":"http://bodang2016.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-08-15T21:45:37.046Z","updated":"2017-08-15T21:45:37.046Z","comments":true,"path":"categories/index.html","permalink":"http://bodang2016.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-15T21:45:37.020Z","updated":"2017-08-15T21:45:37.020Z","comments":true,"path":"tags/index.html","permalink":"http://bodang2016.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"图的邻接矩阵存储法学习笔记","slug":"AdjustListLJ","date":"2017-08-27T08:49:30.000Z","updated":"2017-08-17T17:24:14.603Z","comments":true,"path":"2017/08/27/AdjustListLJ/","link":"","permalink":"http://bodang2016.github.io/2017/08/27/AdjustListLJ/","excerpt":"图的邻接矩阵存储法性质先来回顾下邻接矩阵存储法，邻接矩阵使用一个二维数组来表示节点和节点之间的关系。我们假设A是这个二维数组，那么A中的一个元素A[ig]不仅体现出了节点Vi和结点Vg的关系，而且A[ig]的值可以表示这条边权值的大小。 下面两个例子展示了有向图和无向图使用邻接矩阵存储的结构： 从上图我们可以看到，无向图的邻接矩阵是对称矩阵，也一定是对称矩阵，以上两张图都是不带权的图，因此矩阵中所有边的权值均为1。邻接矩阵的代码实现仅仅使用了二维矩阵，这里不展开写。","text":"图的邻接矩阵存储法性质先来回顾下邻接矩阵存储法，邻接矩阵使用一个二维数组来表示节点和节点之间的关系。我们假设A是这个二维数组，那么A中的一个元素A[ig]不仅体现出了节点Vi和结点Vg的关系，而且A[ig]的值可以表示这条边权值的大小。 下面两个例子展示了有向图和无向图使用邻接矩阵存储的结构： 从上图我们可以看到，无向图的邻接矩阵是对称矩阵，也一定是对称矩阵，以上两张图都是不带权的图，因此矩阵中所有边的权值均为1。邻接矩阵的代码实现仅仅使用了二维矩阵，这里不展开写。 图的邻接表存储法性质图的邻接表存储法使用一维数组存储结点信息（当然也可以使用链表，但使用数组对可以更方便的查找结点信息），图中每个顶点Vi的所有邻接点组成一个线性表存储在对应的结点下，由于邻接点的数目不确定，所以使用单链表进行存储。这个表在无向图中称为顶点Vi的边表，有向图则称为顶点Vi作为弧尾的出边表。 对于上文中的无向图，用邻接表进行存储的内部结构如下： 每一个节点后面所接的结点都是它的邻接点。 实现邻接表的实现相较邻接矩阵来说没那么简单粗暴，完整的功能分为3个类进行实现： 图类 顶点类 操作类 首先来看图类和顶点类，这两个类实现了构造图和顶点所需要的函数，图由一个顶点数组存储，每个顶点包含一个ArrayList存储该顶点的边（在有向图中为出度表），具体实现见代码，这里不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;public class Graph &#123; public Vertex listVertex[]; public boolean direct;// true为有向图，false为无向图 public static int v_index = 0;// 计算当前点在数组内的下标 /* Graph构造 */ public Graph(int num, boolean flag) &#123; direct = flag; listVertex = new Vertex[num]; &#125; /* 添加节点 */ public void addVertex(Vertex v) &#123; listVertex[v_index++] = v; &#125; /* 添加边 */ public void addEdge(int from, int to) &#123; listVertex[from].add_adjacent(listVertex[to]); if (!direct) &#123; listVertex[to].add_adjacent(listVertex[from]); &#125; &#125;&#125;/* 顶点类 */class Vertex &#123; public boolean isVisited;// 节点是否被访问 public ArrayList&lt;Vertex&gt; adjacent = null;// 邻接点列表 public int name; public Vertex() &#123; isVisited = false; &#125; public Vertex(int l) &#123; name = l; isVisited = false; &#125; public void add_adjacent(Vertex data) &#123;// 添加邻接点 if (adjacent == null) adjacent = new ArrayList&lt;Vertex&gt;(); adjacent.add(data); &#125; public ArrayList&lt;Vertex&gt; getAdj() &#123; return adjacent; &#125; @Override public String toString() &#123; return \"Vertex [name=\" + name + \"]\"; &#125;&#125; 操作类实现了图的两种遍历方法在上篇笔记中讨论过，这里深度优先使用栈作为遍历的结构，本质上与迭代是一样的。广度优先使用了ArrayDeque作为数据结构来实现队列，这种结构是一种双向队列，因此也可用于实现栈等其他数据结构。具体实现逻辑见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Scanner;import java.util.Stack;public class Traversal_test &#123; public Vertex dfs[]; public Vertex bfs[]; /* 深度优先遍历 */ public void dfs(Graph graph) &#123; dfs = new Vertex[graph.listVertex.length]; Stack&lt;Vertex&gt; dfs_stack = new Stack&lt;Vertex&gt;(); dfs_stack.push(graph.listVertex[0]); graph.listVertex[0].isVisited = true;// 第一个节点访问 int index = 0; dfs[0] = graph.listVertex[0]; while (!dfs_stack.isEmpty()) &#123;// 栈非空则持续遍历 //getAdjVertex方法只返回没遍历过的顶点，没有则返回null Vertex v = getAdjVertex(dfs_stack.peek()); if (v == null) &#123; dfs_stack.pop(); &#125; else &#123; dfs[++index] = v; v.isVisited = true; dfs_stack.push(v); &#125; &#125; &#125; /* 广度优先遍历 */ public void bfs(Graph graph) &#123; int num = graph.listVertex.length; bfs = new Vertex[num]; ArrayDeque&lt;Vertex&gt; queue = new ArrayDeque&lt;Vertex&gt;(); bfs[0] = graph.listVertex[0]; queue.add(graph.listVertex[0]); graph.listVertex[0].isVisited = true; Vertex vv; int index = 0; while (!queue.isEmpty()) &#123; Vertex v = queue.remove(); while ((vv = getAdjVertex(v)) != null) &#123; queue.add(vv); bfs[++index] = vv; vv.isVisited = true; &#125; &#125; &#125; public static Vertex getAdjVertex(Vertex v) &#123; ArrayList&lt;Vertex&gt; alv = v.getAdj(); if (alv != null) &#123; for (int k = 0; k &lt; alv.size(); k++) &#123; if (alv.get(k).isVisited == false) &#123; return alv.get(k); &#125; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; System.out.println(\"Input the number of vertex:\"); Scanner scan = new Scanner(System.in); int node_num = scan.nextInt(); System.out.println(\"Is this directed graph?\"); boolean flag = scan.nextBoolean(); Graph graph = new Graph(node_num, flag); /* 构建图的节点 */ for (int k = 0; k &lt; node_num; k++) &#123; graph.listVertex[k] = new Vertex(k); &#125; /* 构建图的边 */ System.out.println(\"Input the each node of each edge:-1 to exit\"); int i = 0, j = 0; while ((i = scan.nextInt()) != -1) &#123; j = scan.nextInt(); graph.addEdge(i, j); &#125; Traversal_test dt = new Traversal_test(); /* 深度优先遍历 */ dt.dfs(graph); if (dt.dfs.length &lt; graph.listVertex.length) &#123; System.out.println(\"The graph is not a connected path!\"); &#125; else &#123; System.out.println(\"The depth-first traversal of this graph is:\"); for (int k = 0; k &lt; dt.dfs.length; k++) &#123; System.out.println(dt.dfs[k].toString()); &#125; &#125; /* 广度优先遍历 */ /* 重新构图 */ /* 将节点重置为未访问 */ for (int k = 0; k &lt; node_num; k++) &#123; graph.listVertex[k].isVisited = false; &#125; dt.bfs(graph); if (dt.bfs.length &lt; graph.listVertex.length) &#123; System.out.println(\"The graph is not a connected path!\"); &#125; else &#123; System.out.println(\"The breadth-first traversal of this graph is:\"); for (int k = 0; k &lt; dt.bfs.length; k++) &#123; System.out.println(dt.bfs[k].toString()); &#125; &#125; scan.close(); &#125;&#125; 小结这篇笔记主要总结了图的邻接表实现法，邻接表在教科书和其它数据结构的书上介绍的不多，网上的实现大多也是基于多个类的“全功能”图。我总结这篇笔记的目的是以尽可能简单的代码实现邻接表图的基本功能，这在以后回忆知识点的时候会非常有帮助。到这篇文章，图的常见存储和遍历方法基本做了个笔记，接下来是运用这些方法做一些运用。（判断最短路径，拓扑排序等） 参考阅读： java使用邻接表对图进行深度和广度遍历 Future belongs to the few of us still wiling to get our hands dirty.","categories":[{"name":"Learning Journal","slug":"Learning-Journal","permalink":"http://bodang2016.github.io/categories/Learning-Journal/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://bodang2016.github.io/tags/Algorithm/"},{"name":"Graph","slug":"Graph","permalink":"http://bodang2016.github.io/tags/Graph/"}]},{"title":"图的遍历方法学习笔记","slug":"GraphSearchLJ","date":"2017-08-16T14:58:49.000Z","updated":"2017-08-16T17:50:12.765Z","comments":true,"path":"2017/08/16/GraphSearchLJ/","link":"","permalink":"http://bodang2016.github.io/2017/08/16/GraphSearchLJ/","excerpt":"图的存储方式首先来看一个例子： 要实现图的遍历，需要先将图存储到一个数据结构中，最常用的存储方法是使用一个二维数组e来存储（邻接矩阵存储法），如下： 二维数组中第i行第j列表示的就是顶点i到顶点j是否有边， ∞表示没有边 1表示有边 0表示自己到自己 无向图的邻接矩阵是对称的，实现的时候可以考虑压缩","text":"图的存储方式首先来看一个例子： 要实现图的遍历，需要先将图存储到一个数据结构中，最常用的存储方法是使用一个二维数组e来存储（邻接矩阵存储法），如下： 二维数组中第i行第j列表示的就是顶点i到顶点j是否有边， ∞表示没有边 1表示有边 0表示自己到自己 无向图的邻接矩阵是对称的，实现的时候可以考虑压缩 遍历基本算法深度优先（DFS）从1号顶点出发开始遍历这个图，采用深度优先可以得到下图的遍历结果 每个顶点上方的数字代表这个顶点在第几步被访问，由于我不喜欢书上那种概念的描述方法，这里放一个我在别处看到的思想概括： 深度优先遍历的主要思想： 首先以一个未被访问的顶点作为起点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，回到上一个顶点，继续试探访问别的顶点，直到所有顶点都被访问过。简而言之，就是沿着一条分支遍历直到末端，然后回溯，再沿着另一条进行同样的遍历，知道所有顶点都被访问过。 下面上代码： 12345678910111213141516171819202122232425262728293031323334public class depthFirst &#123; List&lt;Integer&gt; book; //记录顶点是否被访问过 final int[][] edges = &#123; &#123; 0, 1, 1, 9, 1 &#125;, &#123; 1, 0, 9, 1, 9 &#125;, &#123; 1, 9, 0, 9, 1 &#125;, &#123; 9, 1, 9, 0, 9 &#125;, &#123; 1, 9, 1, 9, 0 &#125; &#125;; //邻接矩阵 int scanned = 0; //已遍历的顶点 int verticeNum = 5; //顶点总数 private void dfs(int vertex) &#123; if (book.contains(vertex)) //如果顶点已被遍历过，返回上一级递归 return; //将顶点标为已遍历，输出顶点编号 scanned++; book.add(vertex); System.out.println(vertex); if (scanned == verticeNum) //如果已遍历全部顶点，返回上一级递归 return; for (int i = 0; i &lt; verticeNum; i++) &#123; //继续向下递归 if (edges[vertex][i] == 1) &#123; dfs(i); &#125; &#125; return; &#125; public static void main(String[] args) &#123; depthFirst test = new depthFirst(); test.book = new ArrayList&lt;Integer&gt;(); test.dfs(0); &#125;&#125; 代码的具体逻辑已经注释的很清晰这里不再解释，值得归纳的是深度优先算法使用的递归思想；为了加深对思想的理解我总结了DFS算法的三个递归条件： 边界条件：已遍历顶点等于总顶点（同一连通图） 递归前进段：当前顶点有未遍历过的相邻顶点 递归返回段：返回上一级顶点 广度优先（BFS）同样的我们还看刚才的例子，从1号顶点出发，采用广优先可以得到下图的遍历结果 广度优先的主要思想： 首先以一个未被访问过的顶点作为起始顶点，访问所有与其相邻的顶点，然后对每一个相邻的顶点，再访问它们相邻的并且未被访问过的顶点，直到所有顶点都被访问过，遍历结束。 下面上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class breadthFirst &#123; List&lt;Integer&gt; book; // 记录顶点是否被访问过 final int[][] edges = &#123; &#123; 0, 1, 1, 9, 1 &#125;, &#123; 1, 0, 9, 1, 9 &#125;, &#123; 1, 9, 0, 9, 1 &#125;, &#123; 9, 1, 9, 0, 9 &#125;, &#123; 1, 9, 1, 9, 0 &#125; &#125;; // 邻接矩阵 int scanned = 0; // 已遍历的顶点 int verticeNum = 5; // 顶点总数 Queue&lt;Integer&gt; waitList; //遍历结果队列 public void bfs(int vertex) &#123; waitList.add(vertex); //向队列中加入首个顶点，并将该点标记为已访问 book.add(vertex); scanned++; while (waitList.size() &gt; 0) &#123; //在队列中还有顶点时持续遍历 int curVertex = waitList.poll(); //一次取出一个顶点，输出其数值并遍历其所有未访问的邻居 System.out.println(curVertex); for (int i = 0; i &lt; verticeNum; i++) &#123; if (edges[curVertex][i] == 1 &amp;&amp; !book.contains(i)) &#123; scanned++; book.add(i); waitList.add(i); &#125; &#125; if (scanned == verticeNum) //如果所有顶点都已访问，直接跳出循环 break; &#125; while(waitList.size() &gt; 0) &#123; //顺序输出队列中剩余的顶点 System.out.println(waitList.poll()); &#125; &#125; public static void main(String[] args) &#123; breadthFirst test = new breadthFirst(); test.book = new ArrayList&lt;Integer&gt;(); test.waitList = new LinkedList&lt;Integer&gt;(); test.bfs(0); &#125;&#125; 代码中使用了Queue来对遍历的结果进行保存，这是因为队列先进先出的特性与广度优先的逻辑相同，我们可以将广度优先的关键逻辑总结成两句话 先访问当前顶点的所有邻接点 先访问先被访问的顶点的邻接点（好绕口= =） 上面写的两种算法均使用了ArrayList作为判断顶点是否被访问过的依据，但在遍历的图有两个以上的点入度为0时，或是在遍历森林时，这种方法会加大检索未与起始顶点连通的顶点的复杂度。这里可以考虑使用数组代替ArrayList，当时选择这种方法的原因是因为数组需要在建立时确定长度，但后来一想反正顶点也是二维数组用存的，再用一个数组应该也不会有越界的风险2333，后面具体遇到问题再分析就行。 算法比较 深度优先算法：不保留全部节点，占用内存小，有回溯操作（即入栈，出栈），运行速度慢 广度优先算法：保留全部节点，占用内存大，无回溯操作(即无入栈、出栈)，运行速度快 通常深度优先搜索法不全部保留结点，扩展完的结点从内存中弹出，这样，一般在内存中存储的结点数就是最长的一条路径的值，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。 广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作，所以运行速度比深度优先搜索要快些。 小结这篇笔记主要总结了图的邻接矩阵存储方式和两种遍历方法，邻接矩阵表示法通常适用于一般的图的存储，对于边较少，顶点较多的图会浪费许多空间（稀疏矩阵），这种情况可以采用邻接表进行存储，后续会对两种方法进行细致的比对学习；深度优先和广度优先不仅在图的遍历中适用，在遍历二叉树等数据结构时同样适用。 参考阅读： Java中的递归原理分析 Future belongs to the few of us still wiling to get our hands dirty.","categories":[{"name":"Learning Journal","slug":"Learning-Journal","permalink":"http://bodang2016.github.io/categories/Learning-Journal/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://bodang2016.github.io/tags/Algorithm/"},{"name":"Graph","slug":"Graph","permalink":"http://bodang2016.github.io/tags/Graph/"}]},{"title":"Markdown语法学习笔记","slug":"MarkdownLJ","date":"2017-08-16T08:19:49.000Z","updated":"2017-08-16T18:16:09.865Z","comments":true,"path":"2017/08/16/MarkdownLJ/","link":"","permalink":"http://bodang2016.github.io/2017/08/16/MarkdownLJ/","excerpt":"Markdown的简要规则标题标题作为每一篇文章必需的组成部分，这里首先拿出来说一下。在Markdown中，如果一段文字被定义为标题，只要在这段文字前加#号即可。例如： 123# 一级标题## 二级标题### 三级标题 效果 一级标题二级标题###三级标题 列表Markdown中的列表和Word，Pages中的一样，分为有序和无序表两种。列表的显示只需在文字前加上*或-；有序表则直接在文字前加1. 2. 3. ，符号和文字之间需要加一个空格。","text":"Markdown的简要规则标题标题作为每一篇文章必需的组成部分，这里首先拿出来说一下。在Markdown中，如果一段文字被定义为标题，只要在这段文字前加#号即可。例如： 123# 一级标题## 二级标题### 三级标题 效果 一级标题二级标题###三级标题 列表Markdown中的列表和Word，Pages中的一样，分为有序和无序表两种。列表的显示只需在文字前加上*或-；有序表则直接在文字前加1. 2. 3. ，符号和文字之间需要加一个空格。 1234- 无序表 1* 无序表 21. 有序表 12. 有序表 2 示例 无序表 1 无序表 2 有序表 1 有序表 2 引用如果文章中有引自别处的句子或段落，就要使用引用的格式。引用是可以嵌套的，只需要在文本前加入&gt;这种尖括号（大于号）即可，文本前有几个&gt;表示当前段落的引用层级，这里也要注意符号和文本间的空格。 12&gt;我引&gt;&gt;&gt;我再引233 示例 我引 我再引233 图片与链接插入图片和插入链接的语法很相似，区别在于一个!号，直接上代码 1234插入图片：![]()&#123;images/markdown-170816/yamato.png&#125;插入链接：[我的GitHub](github.com/bodang2016) 示例 这里直接拿打伞大姐姐做展示图了，YAAAMAATOOOO！ 链接示例：My GitHub 粗体 斜体 下划线Markdown中的粗体斜体也非常简单，用一个*包含一段文本就是斜体语法；用两个*包含就是粗体语法；用&lt;u&gt;和&lt;/u&gt;包裹语句就是下划线语法，下面为代码： 123*斜体语法***粗体语法**&lt;u&gt;下划线语法&lt;/u&gt; 示例 斜体语法粗体语法下划线语法 表格在Markdown中使用表格相对来说就比较累了，实现方式有好几种，但不管哪种方式，以下规则都是通用的。 第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开，原生方式每一行的两边都要有管道符。 第二行可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就是右对齐。 下面上代码： 12345|学号|姓名|分数||-|-|-:||小明|男|750||小红|女|110||小陆|男|99| 示例 学号 姓名 分数 小明 男 750 小红 女 110 小陆 男 99 代码框代码框在负责在文章中优雅地呈现代码，在Markdown中实现也非常简单，我常用的方式有两种： 用` 包裹代码文字，这种方法常用于在一行文字的中间穿插代码 用三个` 包裹代码文字并指定代码类型，这种方法常用于大段的代码 下面上代码： 1234567`public static void testFunction()`​···javapublic static void main(String[] args)&#123; testFunction();&#125;​···(此处换成英文字符) 示例 public static void testFunction() 123public static void main(String[] args)&#123; testFunction(); &#125; 分割线分割线的语法只需要三个*号，例如 123A B C D E***F G H I J 示例 A B C D E F G H I J 小结到这里，Markdown的日常语法就基本总结完了，在日后的日志中多加练习，配合好写作工具，写起东西来肯定会行云流水。更多的语法可以参考Markdown的官方文档或者写作工具的帮助文档。 Future belongs to the few of us still wiling to get our hands dirty.","categories":[{"name":"Learning Journal","slug":"Learning-Journal","permalink":"http://bodang2016.github.io/categories/Learning-Journal/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://bodang2016.github.io/tags/Markdown/"},{"name":"Language","slug":"Language","permalink":"http://bodang2016.github.io/tags/Language/"}]}]}